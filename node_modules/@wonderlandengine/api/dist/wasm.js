import { LogTag } from './index.js';
import { Type, defaultPropertyCloner } from './property.js';
import { RetainEmitter } from './utils/event.js';
import { CBOR } from './utils/cbor.js';
import { Logger } from './utils/logger.js';
import { inheritProperties, Component, BrokenComponent, XR, } from './wonderland.js';
/**
 * Default component parameter value per type.
 */
const _componentDefaults = new Map([
    [Type.Bool, false],
    [Type.Int, 0],
    [Type.Float, 0.0],
    [Type.String, ''],
    [Type.Enum, undefined],
    [Type.Object, null],
    [Type.Mesh, null],
    [Type.Texture, null],
    [Type.Material, null],
    [Type.Animation, null],
    [Type.Skin, null],
    [Type.Color, Float32Array.from([0.0, 0.0, 0.0, 1.0])],
    [Type.Vector2, Float32Array.from([0.0, 0.0])],
    [Type.Vector3, Float32Array.from([0.0, 0.0, 0.0])],
    [Type.Vector4, Float32Array.from([0.0, 0.0, 0.0, 0.0])],
]);
/**
 * Setup the defaults value of the properties on a given
 * component class.
 *
 * @param ctor The component class
 */
function _setupDefaults(ctor) {
    for (const name in ctor.Properties) {
        const p = ctor.Properties[name];
        if (p.type === Type.Enum) {
            /* Enum default can be a string or an index. Convert to and/or
             * sanity-check the index. */
            if (p.values?.length) {
                /* Don't try to look up the default if the user specified a
                 * number or we already converted to one. */
                if (typeof p.default !== 'number') {
                    /* If undefined, missing element or wrong type this returns
                     * -1 which becomes 0 below. This matches editor behavior. */
                    p.default = p.values.indexOf(p.default);
                }
                if (p.default < 0 || p.default >= p.values.length) {
                    p.default = 0;
                }
            }
            else {
                /* There's no index value that makes sense */
                p.default = undefined;
            }
        }
        else if ((p.type === Type.Color ||
            p.type === Type.Vector2 ||
            p.type === Type.Vector3 ||
            p.type === Type.Vector4) &&
            Array.isArray(p.default)) {
            /* Defaults provided by user code are currently always a standard
             * array, but become a typed array on the property */
            p.default = Float32Array.from(p.default);
        }
        else if (p.default === undefined) {
            const cloner = p.cloner ?? defaultPropertyCloner;
            p.default = cloner.clone(p.type, _componentDefaults.get(p.type));
        }
        ctor.prototype[name] = p.default;
    }
}
/**
 * Determines a fixed order for property attributes used for deserialization.
 *
 * @param ctor The component class
 */
function _setPropertyOrder(ctor) {
    ctor._propertyOrder = ctor.hasOwnProperty('Properties')
        ? Object.keys(ctor.Properties).sort()
        : [];
}
/**
 * Low-level wrapper to interact with the WebAssembly code.
 *
 * @hidden
 */
export class WASM {
    /**
     * Emscripten worker field.
     *
     * @note This api is meant to be used internally.
     */
    worker = '';
    /**
     * Emscripten wasm field.
     *
     * @note This api is meant to be used internally.
     */
    wasm = null;
    /**
     * Emscripten canvas.
     *
     * @note This api is meant to be used internally.
     */
    canvas = null;
    /**
     * WebGPU device.
     *
     * @note This api is meant to be used internally.
     */
    preinitializedWebGPUDevice = null;
    /** Current WebXR  */
    /**
     * Emscripten WebXR session.
     *
     * @note This api is meant to be used internally.
     */
    webxr_session = null;
    /**
     * Emscripten WebXR request session callback.
     *
     * @note This api is meant to be used internally.
     */
    webxr_requestSession = null;
    /**
     * Emscripten WebXR offer session callback.
     *
     * @note This api is meant to be used internally.
     */
    webxr_offerSession = null;
    /**
     * Emscripten WebXR frame.
     *
     * @note This api is meant to be used internally.
     */
    webxr_frame = null;
    /**
     * Emscripten current WebXR reference space.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpace = null;
    /**
     * Emscripten WebXR reference spaces.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpaces = null;
    /**
     * Emscripten WebXR current reference space type.
     *
     * @note This api is meant to be used internally.
     */
    webxr_refSpaceType = null;
    /**
     * Emscripten WebXR GL projection layer.
     *
     * @note This api is meant to be used internally.
     */
    webxr_baseLayer = null;
    /**
     * Emscripten WebXR framebuffer scale factor.
     *
     * @note This api is meant to be used internally.
     */
    webxr_framebufferScaleFactor = 1.0;
    /**
     * Emscripten WebXR framebuffer(s).
     *
     * @note This api is meant to be used internally.
     */
    /* webxr_fbo will not get overwritten if we are rendering to the
     * default framebuffer, e.g., when using WebXR emulator. */
    webxr_fbo = 0;
    /**
     * Convert a WASM memory view to a JavaScript string.
     *
     * @param ptr Pointer start
     * @param ptrEnd Pointer end
     * @returns JavaScript string
     */
    UTF8ViewToString;
    /** Logger instance. */
    _log = new Logger();
    /** If `true`, logs will not spam the console on error. */
    _deactivate_component_on_error = false;
    /** Temporary memory pointer. */
    _tempMem = null;
    /** Temporary memory size. */
    _tempMemSize = 0;
    /** Temporary float memory view. */
    _tempMemFloat = null;
    /** Temporary int memory view. */
    _tempMemInt = null;
    /** Temporary uint8 memory view. */
    _tempMemUint8 = null;
    /** Temporary uint32 memory view. */
    _tempMemUint32 = null;
    /** Temporary uint16 memory view. */
    _tempMemUint16 = null;
    /** Loading screen .bin file data */
    _loadingScreen = null;
    /** List of callbacks triggered when the scene is loaded. */
    _sceneLoadedCallback = [];
    /** Image cache. */
    _images = [null];
    /** Component instances. */
    _components = null;
    /** Component Type info. */
    _componentTypes = [];
    /** Index per component type name. */
    _componentTypeIndices = {};
    /** Wonderland engine instance. */
    _engine = null;
    /**
     * `true` if this runtime is using physx.
     *
     * @note This api is meant to be used internally.
     */
    _withPhysX = false;
    /** Decoder for UTF8 `ArrayBuffer` to JavaScript string. */
    _utf8Decoder = new TextDecoder('utf8');
    /**
     * Registration index of {@link BrokenComponent}.
     *
     * This is used to return dummy instances when a component
     * isn't registered.
     *
     * @hidden
     */
    _brokenComponentIndex = 0;
    /**
     * Create a new instance of the WebAssembly <> API bridge.
     *
     * @param threads `true` if the runtime used has threads support
     */
    constructor(threads) {
        if (threads) {
            this.UTF8ViewToString = (s, e) => {
                if (!s)
                    return '';
                return this._utf8Decoder.decode(this.HEAPU8.slice(s, e));
            };
        }
        else {
            this.UTF8ViewToString = (s, e) => {
                if (!s)
                    return '';
                return this._utf8Decoder.decode(this.HEAPU8.subarray(s, e));
            };
        }
        this._brokenComponentIndex = this._registerComponent(BrokenComponent);
    }
    /**
     * Reset the cache of the library.
     *
     * @note Should only be called when tearing down the runtime.
     */
    reset() {
        /* Called first to perform cleanup. */
        this._wl_reset();
        this._components = null;
        this._images.length = 1;
        this.allocateTempMemory(1024);
        this._componentTypes = [];
        this._componentTypeIndices = {};
        this._brokenComponentIndex = this._registerComponent(BrokenComponent);
    }
    /**
     * Checks whether the given component is registered or not.
     *
     * @param ctor  A string representing the component typename (e.g., `'cursor-component'`).
     * @returns `true` if the component is registered, `false` otherwise.
     */
    isRegistered(type) {
        return type in this._componentTypeIndices;
    }
    /**
     * Register a legacy component in this Emscripten instance.
     *
     * @note This api is meant to be used internally.
     *
     * @param typeName The name of the component.
     * @param params An object containing the parameters (properties).
     * @param object The object's prototype.
     * @returns The registration index
     */
    _registerComponentLegacy(typeName, params, object) {
        const ctor = class CustomComponent extends Component {
        };
        ctor.TypeName = typeName;
        ctor.Properties = params;
        Object.assign(ctor.prototype, object);
        return this._registerComponent(ctor);
    }
    /**
     * Register a class component in this Emscripten instance.
     *
     * @note This api is meant to be used internally.
     *
     * @param ctor The class to register.
     * @returns The registration index.
     */
    _registerComponent(ctor) {
        if (!ctor.TypeName)
            throw new Error('no name provided for component.');
        if (!ctor.prototype._triggerInit) {
            throw new Error(`registerComponent(): Component ${ctor.TypeName} must extend Component`);
        }
        inheritProperties(ctor);
        _setupDefaults(ctor);
        _setPropertyOrder(ctor);
        const typeIndex = ctor.TypeName in this._componentTypeIndices
            ? this._componentTypeIndices[ctor.TypeName]
            : this._componentTypes.length;
        this._componentTypes[typeIndex] = ctor;
        this._componentTypeIndices[ctor.TypeName] = typeIndex;
        if (ctor === BrokenComponent)
            return typeIndex;
        this._log.info(LogTag.Engine, 'Registered component', ctor.TypeName, `(class ${ctor.name})`, 'with index', typeIndex);
        if (ctor.onRegister)
            ctor.onRegister(this._engine);
        return typeIndex;
    }
    /**
     * Allocate the requested amount of temporary memory
     * in this WASM instance.
     *
     * @param size The number of bytes to allocate
     */
    allocateTempMemory(size) {
        this._log.info(LogTag.Engine, 'Allocating temp mem:', size);
        this._tempMemSize = size;
        if (this._tempMem)
            this._free(this._tempMem);
        this._tempMem = this._malloc(this._tempMemSize);
        this.updateTempMemory();
    }
    /**
     * @todo: Delete this and only keep `allocateTempMemory`
     *
     * @param size Number of bytes to allocate
     */
    requireTempMem(size) {
        if (this._tempMemSize >= size)
            return;
        /* Grow in 1kb increments */
        this.allocateTempMemory(Math.ceil(size / 1024) * 1024);
    }
    /**
     * Update the temporary memory views. This must be called whenever the
     * temporary memory address changes.
     *
     * @note This api is meant to be used internally.
     */
    updateTempMemory() {
        this._tempMemFloat = new Float32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemInt = new Int32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemUint32 = new Uint32Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 2);
        this._tempMemUint16 = new Uint16Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize >> 1);
        this._tempMemUint8 = new Uint8Array(this.HEAP8.buffer, this._tempMem, this._tempMemSize);
    }
    /**
     * Returns a uint8 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required
     * @returns A {@link TypedArray} over the WASM memory
     */
    getTempBufferU8(count) {
        this.requireTempMem(count);
        return this._tempMemUint8;
    }
    /**
     * Returns a uint16 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required
     * @returns A {@link TypedArray} over the WASM memory
     */
    getTempBufferU16(count) {
        this.requireTempMem(count * 2);
        return this._tempMemUint16;
    }
    /**
     * Returns a uint32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferU32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemUint32;
    }
    /**
     * Returns a int32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferI32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemInt;
    }
    /**
     * Returns a float32 buffer view on temporary WASM memory.
     *
     * **Note**: this method might allocate if the requested memory is bigger
     * than the current temporary memory allocated.
     *
     * @param count The number of **elements** required.
     * @returns A {@link TypedArray} over the WASM memory.
     */
    getTempBufferF32(count) {
        this.requireTempMem(count * 4);
        return this._tempMemFloat;
    }
    /**
     * Copy the string into temporary WASM memory and retrieve the pointer.
     *
     * @note This method will compute the strlen and append a `\0`.
     *
     * @note The result should be used **directly** otherwise it might get
     * overridden by any next call modifying the temporary memory.
     *
     * @param str The string to write to temporary memory
     * @param byteOffset The starting byte offset in the temporary memory at which
     *     the string should be written. This is useful when using multiple temporaries.
     * @return The temporary pointer onto the WASM memory
     */
    tempUTF8(str, byteOffset = 0) {
        const strLen = this.lengthBytesUTF8(str) + 1;
        this.requireTempMem(strLen + byteOffset);
        const ptr = this._tempMem + byteOffset;
        this.stringToUTF8(str, ptr, strLen);
        return ptr;
    }
    /**
     * Copy the buffer into the WASM heap.
     *
     * @note The returned pointer must be freed.
     *
     * @param buffer The buffer to copy into the heap.
     * @returns An allocated pointer, that must be free after use.
     */
    copyBufferToHeap(buffer) {
        const size = buffer.byteLength;
        const ptr = this._malloc(size);
        this.HEAPU8.set(new Uint8Array(buffer), ptr);
        return ptr;
    }
    /**
     * Returns `true` if the runtime supports physx or not.
     */
    get withPhysX() {
        return this._withPhysX;
    }
    /**
     * Set the engine instance holding this bridge.
     *
     * @note This api is meant to be used internally.
     *
     * @param engine The engine instance.
     */
    _setEngine(engine) {
        this._engine = engine;
    }
    /* WebAssembly to JS call bridge. */
    _wljs_xr_session_start(mode) {
        if (this._engine.xr === null) {
            this._engine.xr = new XR(this, mode);
            this._engine.onXRSessionStart.notify(this.webxr_session, mode);
        }
    }
    _wljs_xr_session_end() {
        const startEmitter = this._engine.onXRSessionStart;
        if (startEmitter instanceof RetainEmitter)
            startEmitter.reset();
        this._engine.onXRSessionEnd.notify();
        this._engine.xr = null;
    }
    _wljs_xr_disable() {
        /* @todo This could directly be fully handled in JS. */
        this._engine.arSupported = false;
        this._engine.vrSupported = false;
    }
    _wljs_init(withPhysX) {
        this._withPhysX = withPhysX;
        /* Target memory for JS API functions that return arrays */
        this.allocateTempMemory(1024);
    }
    _wljs_scene_switch(index) {
        const scene = this._engine._scenes[index];
        /* Scene can be null during testing with `engine.reset()` */
        this._components = scene?._jsComponents ?? null;
    }
    _wljs_destroy_image(index) {
        const img = this._images[index];
        if (!img)
            return;
        this._images[index] = null;
        if (img.src !== undefined) {
            img.src = '';
        }
        if (img.onload !== undefined) {
            img.onload = null;
        }
        if (img.onerror !== undefined) {
            img.onerror = null;
        }
    }
    _wljs_objects_markDestroyed(sceneIndex, idsPtr, count) {
        const scene = this._engine._scenes[sceneIndex];
        const start = idsPtr >>> 1;
        for (let i = 0; i < count; ++i) {
            const id = this.HEAPU16[start + i];
            scene._destroyObject(id);
        }
    }
    _wljs_scene_initialize(sceneIndex, idsPtr, idsEnd, paramDataPtr, paramDataEndPtr, offsetsPtr, offsetsEndPtr) {
        const cbor = this.HEAPU8.subarray(paramDataPtr, paramDataEndPtr);
        const offsets = this.HEAPU32.subarray(offsetsPtr >>> 2, offsetsEndPtr >>> 2);
        const ids = this.HEAPU16.subarray(idsPtr >>> 1, idsEnd >>> 1);
        const engine = this._engine;
        const scene = engine._scenes[sceneIndex];
        const components = scene._jsComponents;
        let decoded;
        try {
            decoded = CBOR.decode(cbor);
        }
        catch (e) {
            this._log.error(LogTag.Engine, 'Exception during component parameter decoding');
            this._log.error(LogTag.Component, e);
            return;
        }
        if (!Array.isArray(decoded)) {
            this._log.error(LogTag.Engine, 'Parameter data must be an array');
            return;
        }
        if (decoded.length !== ids.length) {
            this._log.error(LogTag.Engine, `Parameter data has size ${decoded.length} but expected ${ids.length}`);
            return;
        }
        for (let i = 0; i < decoded.length; ++i) {
            const id = Component._pack(sceneIndex, ids[i]);
            const index = this._wl_get_js_component_index_for_id(id);
            const component = components[index];
            const ctor = component.constructor;
            if (ctor == BrokenComponent)
                continue;
            const paramNames = ctor._propertyOrder;
            const paramValues = decoded[i];
            if (!Array.isArray(paramValues)) {
                this._log.error(LogTag.Engine, 'Component parameter data must be an array');
                continue;
            }
            if (paramValues.length !== paramNames.length) {
                this._log.error(LogTag.Engine, `Component parameter data has size ${paramValues.length} but expected ${paramNames.length}`);
                continue;
            }
            for (let j = 0; j < paramValues.length; ++j) {
                const name = paramNames[j];
                const property = ctor.Properties[name];
                const type = property.type;
                let value = paramValues[j];
                /* Default values are sent as undefined to avoid wasting space */
                if (value === undefined) {
                    const cloner = property.cloner ?? defaultPropertyCloner;
                    value = cloner.clone(type, property.default);
                    component[name] = value;
                    continue;
                }
                /* This skips unset resource parameters as those are sent
                 * directly with type null. Offsets for Int and Float types
                 * should always be 0. */
                /** @todo CBOR tag to mark resources? Wastes a byte though. */
                if (typeof value === 'number') {
                    value += offsets[type];
                }
                switch (type) {
                    case Type.Bool:
                    case Type.Int:
                    case Type.Float:
                    case Type.String:
                    case Type.Enum:
                    case Type.Vector2:
                    case Type.Vector3:
                    case Type.Vector4:
                        /* Nothing to do */
                        break;
                    case Type.Object:
                        value = value
                            ? scene.wrap(this._wl_object_id(scene._index, value))
                            : null;
                        break;
                    case Type.Mesh:
                        value = engine.meshes.wrap(value);
                        break;
                    case Type.Texture:
                        value = engine.textures.wrap(value);
                        break;
                    case Type.Material:
                        value = engine.materials.wrap(value);
                        break;
                    case Type.Animation:
                        value = scene.animations.wrap(value);
                        break;
                    case Type.Skin:
                        value = scene.skins.wrap(value);
                        break;
                    case Type.Color:
                        /* Colors are sent as Uint8Array. Normalize positive
                         * integer values to 0-1. Don't assume any bit size
                         * here, could become Uint16Array as well. */
                        const max = (1 << (value.BYTES_PER_ELEMENT * 8)) - 1;
                        value = Float32Array.from(value, (f, _) => f / max);
                        break;
                }
                component[name] = value;
            }
        }
    }
    _wljs_set_component_param_translation(scene, component, param, valuePtr, valueEndPtr) {
        const components = this._engine._scenes[scene]._jsComponents;
        const comp = components[component];
        const value = this.UTF8ViewToString(valuePtr, valueEndPtr);
        const ctor = comp.constructor;
        const paramName = ctor._propertyOrder[param];
        comp[paramName] = value;
    }
    _wljs_get_component_type_index(namePtr, nameEndPtr) {
        const typename = this.UTF8ViewToString(namePtr, nameEndPtr);
        const index = this._componentTypeIndices[typename];
        if (index === undefined) {
            return this._brokenComponentIndex;
        }
        return index;
    }
    _wljs_component_create(sceneIndex, index, id, type, object) {
        const scene = this._engine._scenes[sceneIndex];
        scene._components.createJs(index, id, type, object);
    }
    _wljs_component_init(scene, component) {
        const components = this._engine._scenes[scene]._jsComponents;
        const c = components[component];
        c._triggerInit();
    }
    _wljs_component_update(component, dt) {
        const c = this._components[component];
        c._triggerUpdate(dt);
    }
    _wljs_component_onActivate(component) {
        const c = this._components[component];
        c._triggerOnActivate();
    }
    _wljs_component_onDeactivate(component) {
        const c = this._components[component];
        c._triggerOnDeactivate();
    }
    _wljs_component_markDestroyed(sceneIndex, manager, componentId) {
        const scene = this._engine._scenes[sceneIndex];
        const component = scene._components.get(manager, componentId);
        component?._triggerOnDestroy();
    }
    _wljs_swap(scene, a, b) {
        const components = this._engine._scenes[scene]._jsComponents;
        const componentA = components[a];
        components[a] = components[b];
        components[b] = componentA;
    }
    _wljs_copy(srcSceneIndex, srcIndex, dstSceneIndex, dstIndex, offsetsPtr) {
        const srcScene = this._engine._scenes[srcSceneIndex];
        const dstScene = this._engine._scenes[dstSceneIndex];
        const destComp = dstScene._jsComponents[dstIndex];
        const srcComp = srcScene._jsComponents[srcIndex];
        try {
            destComp._copy(srcComp, offsetsPtr);
        }
        catch (e) {
            this._log.error(LogTag.Component, `Exception during ${destComp.type} copy() on object ${destComp.object.name}`);
            this._log.error(LogTag.Component, e);
        }
    }
    /**
     * Forward an animation event to a corresponding
     * {@link AnimationComponent}
     *
     * @note This api is meant to be used internally. Please have a look at
     * {@link AnimationComponent.onEvent} instead.
     *
     * @param componentId Component id in the manager
     * @param namePtr Pointer to UTF8 event name
     * @param nameEndPtr Pointer to end of UTF8 event name
     */
    _wljs_trigger_animationEvent(componentId, namePtr, nameEndPtr) {
        const scene = this._engine.scene;
        const comp = scene._components.wrapAnimation(componentId);
        const nameStr = this.UTF8ViewToString(namePtr, nameEndPtr);
        comp.onEvent.notify(nameStr);
    }
}
/*
 * Api <> Runtime compatibility.
 *
 * Some features exposed in the API are only available from a specific
 * runtime version.
 *
 * Every added feature must throw by default. If the runtime loaded
 * has the specific feature, the method will be overwritten by Emscripten
 * upon loading.
 */
/**
 * Throwing function used for features added in a patch version.
 *
 * #### Usage
 *
 * ```ts
 * const requireRuntime1_1_1 = throwInvalidRuntime('1.1.1');
 * WASM.prototype._wl_new_function = requireRuntime1_1_1;
 * ```
 *
 * @param version The version in which the feature was added.
 * @returns A function that will throw when called.
 */
function throwInvalidRuntime(version) {
    return function () {
        throw new Error(`Feature added in version ${version}.` +
            `\n\tâ†’ Please use a Wonderland Engine editor version >= ${version}`);
    };
}
/** @todo Remove at 1.3.0 */
const requireRuntime1_2_1 = throwInvalidRuntime('1.2.1');
WASM.prototype._wl_text_component_get_wrapMode = requireRuntime1_2_1;
WASM.prototype._wl_text_component_set_wrapMode = requireRuntime1_2_1;
WASM.prototype._wl_text_component_get_wrapWidth = requireRuntime1_2_1;
WASM.prototype._wl_text_component_set_wrapWidth = requireRuntime1_2_1;
WASM.prototype._wl_font_get_outlineSize = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_start = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_buffer_size = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_next = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_abort = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_end_prefab = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_end_main = requireRuntime1_2_1;
WASM.prototype._wl_scene_create_chunked_end_queued = requireRuntime1_2_1;
