import { ComponentManagers } from './component.js';
import { WonderlandEngine } from './engine.js';
import { ResourceManager, SceneResource } from './resources/resource.js';
import { ProgressCallback } from './types.js';
import { Animation, Component, Object3D, Skin } from './wonderland.js';
/** Scene loading options. */
export interface SceneLoadOptions {
    /** An in-memory buffer, containing the bytes of a `.bin` file. */
    buffer: ArrayBuffer;
    /** Path from which resources are resolved (images, languages, etc...). */
    baseURL: string;
    /** If `true`, dispatches a ready event in the document. */
    dispatchReadyEvent?: boolean;
}
/** Loading options for in-memory data. */
export interface InMemoryLoadOptions {
    /** An in-memory buffer, containing the bytes of a `.bin` file. */
    buffer: ArrayBuffer;
    /** Path from which resources are resolved (images, languages, etc...). */
    baseURL: string;
    /** Name of the file. This is the same that will be retrieved via {@link Scene#filename} */
    filename?: string;
}
/** Options for loading files from a URL. */
export interface UrlLoadOptions {
    /** URL to load. */
    url: string;
    /** Signal to abort the file fetch request. */
    signal?: AbortSignal;
}
/** Options used during loading. */
export type LoadOptions = string | UrlLoadOptions;
/**
 * Base class for prefabs, scenes, and glTF.
 *
 * For more information have a look at the derived types:
 * - {@link Scene} for Wonderland Engine activatable scenes (.bin)
 * - {@link PrefabGLTF} for glTF scenes
 *
 * #### Resources
 *
 * While **meshes**, **textures**, and **materials** are shared
 * on the {@link WonderlandEngine} instance, a scene comes with:
 * - Animations: Managed using {@link Prefab.animations}
 * - Skins: Managed using {@link Prefab.skins}
 *
 * Those resources are bound to the object hierarchy and are thus required to be
 * per-scene.
 *
 * #### Destruction
 *
 * For now, destroying a scene doesn't automatically remove the resources it
 * references in the engine. For more information, have a look at the
 * {@link Scene.destroy} method.
 *
 * #### Isolation
 *
 * It's forbidden to mix objects and components from different scenes, e.g.,
 *
 * ```js
 * const objA = sceneA.addObject();
 * const objB = sceneB.addObject();
 * objA.parent = objB; // Throws
 * ```
 *
 * @category scene
 *
 * @since 1.2.0
 */
export declare class Prefab {
    /**
     * Load an `ArrayBuffer` using fetch.
     *
     * @param opts The url or options.
     * @param progress Progress callback
     * @returns An {@link InMemoryLoadOptions} object.
     *
     * @hidden
     */
    static loadBuffer(options: LoadOptions, progress: ProgressCallback): Promise<InMemoryLoadOptions>;
    /**
     * Validate the in memory options.
     *
     * @param options Options to validate.
     * @returns Validated options object.
     *
     * @hidden
     */
    static validateBufferOptions(options: InMemoryLoadOptions): {
        buffer: ArrayBuffer;
        baseURL: string;
        url: string;
    };
    /** Index in the scene manager. @hidden */
    readonly _index: number;
    /** @hidden */
    protected _engine: WonderlandEngine;
    /**
     * Component manager caching to avoid GC.
     *
     * @hidden
     */
    readonly _components: ComponentManagers;
    /**
     * JavaScript components for this scene.
     *
     * This array is moved into the WASM instance upon activation.
     *
     * @hidden
     */
    readonly _jsComponents: Component[];
    /** @hidden */
    private readonly _animations;
    /** @hidden */
    private readonly _skins;
    /**
     * Object class instances to avoid GC.
     *
     * @hidden
     */
    private readonly _objectCache;
    /**
     * @note This api is meant to be used internally.
     *
     * @hidden
     */
    constructor(engine: WonderlandEngine, index: number);
    /**
     * Add an object to the scene.
     *
     * @param parent Parent object or `null`.
     * @returns A newly created object.
     */
    addObject(parent?: Object3D | null): Object3D;
    /**
     * Batch-add objects to the scene.
     *
     * Will provide better performance for adding multiple objects (e.g. > 16)
     * than calling {@link Scene#addObject} repeatedly in a loop.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * convervatively grow the memory in small steps.
     *
     * @experimental This API might change in upcoming versions.
     *
     * @param count Number of objects to add.
     * @param parent Parent object or `null`, default `null`.
     * @param componentCountHint Hint for how many components in total will
     *      be added to the created objects afterwards, default `0`.
     * @returns Newly created objects
     */
    addObjects(count: number, parent?: Object3D | null, componentCountHint?: number): Object3D[];
    /**
     * Pre-allocate memory for a given amount of objects and components.
     *
     * Will provide better performance for adding objects later with {@link Scene#addObject}
     * and {@link Scene#addObjects}.
     *
     * By providing upfront information of how many objects will be required,
     * the engine is able to batch-allocate the required memory rather than
     * conservatively grow the memory in small steps.
     *
     * **Experimental:** This API might change in upcoming versions.
     *
     * @param objectCount Number of objects to add.
     * @param componentCountPerType Amount of components to
     *      allocate for {@link Object3D.addComponent}, e.g. `{mesh: 100, collision: 200, "my-comp": 100}`.
     * @since 0.8.10
     */
    reserveObjects(objectCount: number, componentCountPerType: Record<string, number>): void;
    /**
     * Root object's children.
     *
     * See {@link Object3D.getChildren} for more information.
     *
     * @param out Destination array, expected to have at least `this.childrenCount` elements.
     * @returns The `out` parameter.
     */
    getChildren(out?: Object3D[]): Object3D[];
    /**
     * Top-level objects of this scene.
     *
     * See {@link Object3D.children} for more information.
     *
     * @since 1.2.0
     */
    get children(): Object3D[];
    /** The number of children of the root object. */
    get childrenCount(): number;
    /**
     * Search for objects matching the name.
     *
     * See {@link Object3D.findByName} for more information.
     *
     * @param name The name to search for.
     * @param recursive If `true`, the method will look at all the objects of
     *     this scene. If `false`, this method will only perform the search in
     *     root objects.
     * @returns An array of {@link Object3D} matching the name.
     *
     * @since 1.2.0
     */
    findByName(name: string, recursive?: boolean): Object3D[];
    /**
     * Search for all **top-level** objects matching the name.
     *
     * See {@link Object3D.findByNameDirect} for more information.
     *
     * @param name The name to search for.
     * @returns An array of {@link Object3D} matching the name.
     *
     * @since 1.2.0
     */
    findByNameDirect(name: string): Object3D[];
    /**
     * Search for **all objects** matching the name.
     *
     * See {@link Object3D.findByNameRecursive} for more information.
     *
     * @param name The name to search for.
     * @returns An array of {@link Object3D} matching the name.
     *
     * @since 1.2.0
     */
    findByNameRecursive(name: string): Object3D[];
    /**
     * Wrap an object ID using {@link Object}.
     *
     * @note This method performs caching and will return the same
     * instance on subsequent calls.
     *
     * @param objectId ID of the object to create.
     *
     * @returns The object
     */
    wrap(objectId: number): Object3D;
    /**
     * Destroy the scene.
     *
     * For now, destroying a scene doesn't remove the resources it references. Thus,
     * you will need to reload a main scene to free the memory.
     *
     * For more information about destruction, have a look at the {@link Scene.destroy} method.
     */
    destroy(): void;
    /**
     * `true` if the scene is active, `false` otherwise.
     *
     * Always false for {@link Prefab} and {@link PrefabGLTF}.
     */
    get isActive(): boolean;
    /**
     * Relative directory of the scene that was loaded.
     *
     * This is used for loading any files relative to the scene.
     */
    get baseURL(): string;
    /**
     * Filename used when loading the file.
     *
     * If the scenes was loaded from memory and no filename was provided,
     * this accessor will return an empty string.
     */
    get filename(): string;
    /** Animation resources */
    get animations(): ResourceManager<Animation>;
    /** Skin resources */
    get skins(): ResourceManager<Skin>;
    /** Hosting engine instance. */
    get engine(): WonderlandEngine;
    /**
     * `true` if the object is destroyed, `false` otherwise.
     *
     * If {@link WonderlandEngine.erasePrototypeOnDestroy} is `true`,
     * reading a class attribute / method will throw.
     */
    get isDestroyed(): boolean;
    toString(): string;
    /**
     * Checks that the input's scene is the same as this instance.
     *
     * It is forbidden to mix objects and components from different scenes, e.g.,
     *
     * ```js
     * const objA = sceneA.addObject();
     * const objB = sceneA.addObject();
     * objA.parent = objB; // Throws
     * ```
     *
     * @param other Object / component to check.
     *
     * @throws If other's scene isn't the same reference as this.
     */
    assertOrigin(other: Object3D | Component | SceneResource | undefined | null): void;
    /**
     * Download dependencies and initialize the scene.
     *
     * @hidden
     */
    _initialize(): void;
    /**
     * Perform cleanup upon object destruction.
     *
     * @param localId The id to destroy.
     *
     * @hidden
     */
    _destroyObject(localId: number): void;
}
